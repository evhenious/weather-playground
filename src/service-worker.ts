/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst } from 'workbox-strategies';
import { CustomCacheFirst } from './serviceWorker/CustomCacheFirst'
import { SyncTimeHandler } from './serviceWorker/SyncTimeHandler';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Cache for weather resolver
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.host.includes('openweathermap') && url.pathname.includes('/weather'),
  // Customize this strategy as needed
  new CustomCacheFirst({
    cacheName: 'weather-cache',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the least-recently used entries are removed.
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 15, // 15 min to keep weather response
        maxEntries: 5
      }),
      new SyncTimeHandler('weather-cache')
    ],
  })
);

// Cache for city resolver
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.href.includes('/api/geo?'),
  new CacheFirst({
    cacheName: 'city-name-cache',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24, // 1 day to keep city names response
        maxEntries: 10
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.